## 날짜: 2025-03-18

# JPA

- ORM을 구현하기 위한 표준 인터페이스.
- 실제 구현체(Hibernate)를 통해 동작함

## ORM

- 객체지향 언어에서 사용하는 객체를 RDB와 연결시켜주는 기술
- 단순 SQL문을 작성하지 않아도 되고, 유지 보수에 좋다.
- 복잡한 쿼리 사용하기에는 부족하다.
- 성능이 직접 짠 SQL문보다 안좋을 수 있다.

## 주요 어노테이션

- @Entity : 클래스를 JPA 엔티티로 선언한다는 의미
- @Table : 엔티티의 테이블 이름 설정
- @Id : 식별자 설정
- @GeneratedValue : PK생성 전략
- @Enumerated : enum 타입 지정. EnumType.ORDINAL 사용 지양

## 영속성 컨텍스트

- 엔티티를 영구적으로 저장, 관리하는 가상의 공간.
- 트랜잭션 범위 내에서 동작
- 1차 캐시 : 동일 트랜잭션 내에서 같은 PK 조회(select)에 대해서는 DB가 아닌 캐시를 사용 → 동일성 보장
- Dirty Checking : 엔티티의 변경된 부분을 모아두었다가 트랜잭션이 끝나면 변경된 부분만 자동으로 update 실행.
- Lazy Loading
    - 엔티티를 가져올 때 관련된 엔티티(매핑된 엔티티)를 실제 사용 시점에 가져오는 것.
    - N+1 문제의 근본적 해결이 되지 않음. (연관 객체를 다수 로딩했을 때 결국 발생.)
- 쓰기 지연 : DB의 변경 사항(insert, update, delete)을 매번 적용시키지 않고, 모아두었다가 일괄 처리

## 엔티티 생명주기

- 비영속(Transient) : DB와는 무관한 상태
- 영속(Managed) : DB에 직접적인 변경이 이루어진 상태
- 준영속(Detached) : DB에서 불러온 객체의 변경사항은 있지만, DB에는 업데이트되지 않은 상태
- 삭제(Removed) : DB에서 값이 삭제된 상태

## 엔티티 매니저

- DB 작업(CRUD)을 수행하는 객체
- 스레드 세이프하지 않음. → 데이터가 꼬일 수 있음

### 오늘의 도전 과제와 해결 방법
- 도전 과제 1: TIL 정리
- 도전 과제 2: 과제 회고 작성하고, 기타 버그 수정.