## 날짜: 2025-03-21

# AOP란

- 관점 지향 프로그램이란 여러 곳에서 자주 사용되는 공통 기능을 모듈화하여 사용하는 것.
- 유지보수가 편리하고 재사용성이 높다.

# AOP 프록시란

- 비즈니스 로직같은 핵심 기능을 감싸서 그 로직이 실행되기 전이나 실행된 후에 부가적인 기능을 삽입할 수 있도록 만들어주는 프록시객체
- 로깅, 트랙잭션, 보안 등의 부가 기능을 삽입
- 즉, 우리가 짠 코드(비즈니스 로직)에 프록시 객체{로그같은 공통 기능(부가 기능)}로 감싸서 사용하는 것.

  → 우리가 짠 코드가 직접 호출되는 것이 아닌 프록시 객체를 거쳐서 그 안에서 호출되는 순서.

  ex) 프록시 객체 호출 → 로깅 작업 → 프록시 객체에서 원하는 로직 호출

- 로깅하는 코드를 매 함수, 로직마다 짤 필요가 없다. → 유지보수 및 코드 재사용성
- 프록시 패턴이란
    - **프록시 패턴에서 말하는 프록시와 AOP 프록시는 다른 목적으로 사용되기 때문에 굳이 알필요는 없음.**
    - 객체를 참조하려고 할 때, 그 객체를 직접 참조하는 것이 아닌 그 객체를 대변하는 객체를 통해 접근하는 방식.
    - 실제 객체가 필요할 때 실제 객체의 생성이 이루어진다. (Lazy Loading)
    - 해당 객체가 메모리에 존재하지 않아도 기본적인 정보를 참조하거나 설정할 수 있다.
    - 메모리에 존재하지 않는다? → 프록시가 메모리에 존재하고, 진짜 객체가 필요할 때 프록시가 실제 객체를 가져온다.
    - 여기서 말하는 기본적인 정보라는 것은 실제 객체의 일부 정보같은 것이 될 수 있다.
    - 메모리, 성능 최적화가 좋음

## 어떻게 만들어 지는가

- @Aspect 어노테이션을 감지
- 내 클래스의 빈을 생성할 때 BeanPostProcessor가 개입하여 프록시 객체로 내 로직을 감싸서 반환
- 인터페이스 기반의 JDK 동적 프록시 또는 클래스 상속 기반의 CGLIB 프록시로 만들어짐
- 컨테이너에 **내 로직을 담고 있는 프록시**가 등록됨

### JDK 동적 프록시와 CGLIB에 대해

- AOP로 감싸고 싶은 내 로직이 인터페이스로 구현된 것이라면 JDK 동적 프록시를 만든다.
- 만약 인터페이스가 아닌 일반 클래스라면 이 클래스를 상속받아서 구현하는 CGLIB 프록시를 만든다.
- 스프링은 기본적으로 JDK 동적 프록시 → CGLIB 순으로 시도한다.
    - 상속보다는 인터페이스가 더 유연하고, 자바 내부에 구현되어 있기 때문에 JDK 동적 프록시를 먼저 사용한다.
    - 속도 측면에서도 JDK 동적 프록시와 CGLIB의 차이가 크지 않음
- final 클래스는 상속이 안되기 때문에 CGLIB로 프록시를 생성하지 못한다.

# 그 외 추가 사항

- 함수가 내부 함수를 호출하는 부분에 대해서는 AOP가 적용되지 않는다.

```java
public class OrderService {
    public void order() { // 이 함수에 대해 AOP를 적용할 떄
        validate(); // 이 부분에서는 적용되지 않음
    }

    public void validate() {
        ...
    }
}
```

- AOP가 적용되려면 반드시 Bean이어여 함.
- Spring AOP는 프록시 기반이기 때문에 필드, 생성자에는 적용할 수 없고 오로지 메서드에만 가능하다.
    - 필드, 생성자에서 AOP를 적용하고 시다면 AspectJ를 사용하면 가능.
    - AspectJ를 쓰면 내부 호출 AOP도 가능.
- AspectJ가 더 좋아보이는데 Spring AOP를 사용하는 이유는 AspectJ는 무겁기도 하고, Spring AOP로도 대부분의 요구사항에 대해 충분히 잘 동작한다.

---

# IoC

- Inversion of Control. 제어의 역전
- 제어의 주도권이 개발자가 아닌 프레임워크로 역전된다 해서 제어의 역전이다.
- 여기서 말하는 제어란 객체의 생성, 초기화, 의존성 주입 등을 말한다.

## IoC 컨테이너

- 객체의 생성, 초기화, 의존성 주입 등 이런 제어를 관리하는 것을 말한다.
- BeanFactory와 ApplicationContext로 구현이 된다.
- 두 컨테이너 중 특별한 이유가 없다면 ApplicationContext를 사용한다.
    - AppCont가 BeanFac의 기능을 포함하며 추가 기능을 제공하기 때문
- BeanFactory는 lazy loading으로, ApplicationContext는 Pre-Loading(eager)으로 Bean을 불러온다.
    - AppCont에서도 `@Lazy` 어노테이션으로 Lazy loading을 구현할 수 있다.

# 의존성 주입

- 어떤 객체가 다른 객체를 필요로 할 때 이 객체를 직접 만들지 않고 외부에서 넣어주는 것.
- 객체간의 결합도가 낮아진다.
    - 객체가 다른 객체를 쓸 때 언제든 전혀 다른 객체로 갈아 끼울 수 있다.

## 동작 방식

1. 먼저 `@Component` 가 붙은 클래스를 스캔
2. IoC 컨테이너에 의해 객체로 생성됨. 이 객체를 Bean이라고 한다.
    1. 스프링은 내부적으로 bean들을 map 형태로 저장한다.
    2. ApplicationContext의 내부 캐시에 저장된다.
3. 생성자의 파라미터를 보고 필요한 객체가 Bean에 등록되어있는지 확인하고 등록되어 있다면 생성자를 넣어준다.
    1. 없으면 오류가 발생하는데, @Autowired(required = false)를 쓰면 없어도 동작할 수 있다.

## 오늘의 회고
- 프록시 객체에 대해 완벽하게 이해한 것 같아서 매우 만족스럽다. 말로는 많이 듣긴 했지만 사실 와닿지는 않았는데 프록시 객체라는 개념을 통해 확실히 이해가 되었다.
- 관련 내용인 프록시 패턴, 프록시 서버에 대해서도 공부를 좀 더 해봐야겠다.