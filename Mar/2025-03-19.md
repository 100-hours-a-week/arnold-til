## 날짜: 2025-03-19

## 캐시

### 1차 캐시

- 영속성 컨텍스트 내부에 있는 캐시
- 동일 트랜잭션 내에서 한 번 조회한 데이터를 조회할 때 sql에 접근하지 않고 데이터를 읽어올 수 있게 함

### 2차 캐시

- 1차보다 범위가 더 넓은 캐시
- 주로 읽기 전용 데이터 or 자주 변경되지 않는 데이터에 적합

## 연관 관계 매핑

### 일대일(@OneToOne)

- 한쪽 테이블이 주 테이블
- 단방향 : 한 쪽 엔티티만 다른 엔티티를 참조
- 양방향 : 서로가 엔티티를 참조.
- 양방향 매핑에서 JSON화 할 때, 순환참조를 조심해야 함.

### 일대다(@OneToMany)

- 하나의 엔티티가 여러개의 엔티티를 참조
- 성능 이슈로 단방향 일대다는 잘 사용하지 않음. (외래키의 위치가 이상해지기 때문)

### 다대일(@ManyToOne)

- 여러개의 엔티티가 하나의 엔티티를 참조
- 일반적으로 Eager loading을 사용

### 다대다(@ManyToMany)

- 일반적으로 사용하지 않음.
- OneToMany ↔ ManyToOne ↔ OneToMany로 중간 테이블을 명시적으로 만들고 분리해서 사용.
- 애초에 ManyToMany를 사용해도 내부적으로 중간 테이블을 만들어서 관리함.

## Fetch 전략

### Eagar 로딩

- 연관된 엔티티를 미리 로딩
- 불필요한 데이터까지 불러와서 성능 저하 이슈가 발생할 수 있음.

### Lazy 로딩

- 연관된 엔티티를 필요할때 로딩
- 연관 데이터에 접근할 때마다 추가 쿼리 발생

## JPQL

- JPA에서 제공하는 SQL 문법
- 엔티티 객체를 대상으로 하는 쿼리
- Native Query : DB의 SQL문을 직접 작성. → DB가 바뀌면 문법도 바뀌기 때문에 코드 변경도 생김. JPA를 사용하는 의미가 줄어든다.

## Native Query

- DB에 사용되는 쿼리문
- JPA에서는 @Query(value = “쿼리문”, nativeQuery = true)로 작성하여 사용할 수 있다.
- DB의 종류에 따라 문법이 달라지는 문제가 있어서 잘 사용하지 않는 것이 좋다.

## Entity Graph

- Fetch 전략을 동적으로 지정하는 방법
- 연관 되어있는 특정 엔티티들의 lazy or eagar 로딩을 각각 정하는 것

### 오늘의 도전 과제와 해결 방법
- 도전 과제 1: TIL 정리
- 도전 과제 2: 코딩테스트 준비