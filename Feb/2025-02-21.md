## 날짜: 2025-02-21

# 2/21 딥다이브

1. 절차지향형, 함수지향형, 객체지향형 프로그래밍 패러다임의 차이에 대해 설명해주세요.
2. 리플로우와 리페인트를 줄일 수 있는 방법에 대해 설명해주세요.

# 선언형 프로그래밍과 명령형 프로그래밍

## 선언형 프로그래밍

- 무엇이 나타나야 하는지를 프로그래밍하는 것이다.
- 예를 들어 웹 페이지. 제목, 본문, 스타일 등등은 “어떤 방법”으로 화면에 놓여 있는 것이 아닌 “무엇”이 나타나야 하는지를 나타낸다. html, css, 대부분의 SQL이 선언형 프로그래밍에 포함된다.
    - SQL 문법은 어떤 데이터를 가져올지를 정하지, 어떻게 가져올지는 내부 로직이 정한다.
- 함수지향형 프로그래밍을 하위에 포함.

### 함수지향형 프로그래밍

- 함수로 이루어진 프로그래밍 방법으로, 선언형 패러다임의 일종이다.
- 순수 함수를 중심으로 **상태변경과 side effect를 최소화** 하는 프로그래밍.
    - 순수 함수 : 외부 상태를 변경하거나 참조하지 않는 함수.
- 파이썬, 자바에서 lambda, map, filter 등을 지원하여 함수형 프로그래밍이 사용될 수 있다.
- 파이선) lambda는 익명함수, map()은 고차함수
    - 익명함수 : 이름이 없는 함수
    - 고차함수 : 함수를 매개변수로 사용

## 명령형 프로그래밍

- 프로그램의 상태를 명령의 연속으로 동작하는 프로그래밍 방법으로, 무엇을 해야하는지 보다는 “어떻게” 해야 하는지를 보여준다.
- 컴퓨터가 수행할 명령들을 순서대로 써놓은 것이다.
- 절차지향형, 객체지행형 프로그래밍을 하위에 포함한다.

```python
nums = [1, 2, 3, 4]

# 함수지향형
functionalSquared = list(map(lambda x : x*x, nums)) 

# 명령형
imperativeSquared = []

for num in nums:
	imperativeSquared.append(num * num) # imperativeSquared의 상태가 매 반복마다 변경됨.
```

### 절차지향형 프로그래밍

- 로직이 수행되어야 할 순차적인 과정으로 구성되어 있는 프로그래밍 방법이다.
    - 순차적인 과정이라는 의미가 반드시 위에서 아래로 실행되는 것을 의미하지는 않음.
    - 순차적인 과정이라는 것은 코드의 실행 흐름이 예측 가능하고 논리적으로 순서가 정해져 있음을 의미한다.
    - vs 비순차적 : 단순한 예시로는 thread를 이용한 비동기 프로그래밍.
- 일이 진행되는 방식(순서)으로 코드를 구현하면 되기 때문에 직관적이다.
- 함수단위의 재사용은 용이하지만 객체단위의 재사용이 어려움.
- 단순 스크립트나 가벼운 프로젝트에 사용된다.
- 하위 개념으로는 프로그래밍 패러다임의 시초인, 다익스트라가 고안한 구조적 프로그래밍이 있다.

### 객체지향형 프로그래밍

- 객체를 중심으로 객체 안에 데이터와 함수를 묶어 넣고, 이 객체를 이용하여 객체간의 상호작용을 구현한 프로그래밍 방법이다.
- 우리가 흔히 아는 캡슐화, 다형성, 상속, 추상화가 가능한 프로그래밍 패러다임이다.

# 결론

- 함수지향형 프로그래밍, 절차지향형 프로그래밍, 객체지향형 프로그래밍은 크게 함수지향형(선언형 프로그래밍) vs 절차지향형, 객체지향형 (명령형 프로그래밍)으로 나눌 수 있다.
- 선언형 프로그래밍은 무엇을 나타날지를 프로그래밍 하는 것이고, 명령형 프로그래밍은 어떻게 나타낼지를 프로그래밍 하는 것이다.
- 절차지향형은 논리적 순서와 실행 흐름이 명확한 것에 집중하고, 객체지향형은 객체에 집중하여 코드의 실행 흐름이 객체간의 상호작용을 통해 진행되는 것에 집중한다.

# 리플로우 (reflow)

- 요소의 크기 또는 위치, 창의 크기가 변경될 때 발생하는 문제로, 브라우저가 레이아웃을 다시 계산하는 것을 의미한다. (ex. width, height, display, position 등의 변경)
- 브라우저가 레이아웃을 다시 계산할 때 비용이 발생하고, 속도에 영향을 준다.
- html과 js의 영향을 많이 받는다. (동적으로 변경하는 상황)
- css에서는 `display : flex`를 사용할 때, 창 크기를 조절하면 내부 요소의 위치를 다시 계산한다.
- 리플로우는 반드시 발생할 수 밖에 없는 문제라 횟수를 줄이는 것이 중요하다.

# 리페인트 (repaint)

- 요소의 스타일이 변경될 때 브라우저가 화면을 다시 그리는 것을 의미한다. (ex. color, shadow 등의 변경)
- 레이아웃을 다시 계산하는 것이 아닌 화면을 다시 그리는 과정.
- 리플로우에 비해 가벼운 작업이지만 빈번하게 발생하면 성능을 저하시키는 것은 마찬가지다.
- css의 영향을 많이 받는다.

# 리플로우와 리페인트를 줄이는 방법

- 요소의 변경이 발생하는 코드 순서를 적절히 배치한다.

```jsx
// 리플로우가 여러번 발생하는 예
var h1 = div1.clientHeight;  // 브라우저가 최신 레이아웃을 계산 → 리플로우 발생
div1.style.height = h1 + 10 + "px";  // 스타일 변경 → 리플로우 발생

var h2 = div2.clientHeight;  // 또다시 브라우저가 최신 레이아웃을 계산 → 리플로우 발생
div2.style.height = h2 + 10 + "px";  // 스타일 변경 → 리플로우 발생

// 리플로우가 한번만 발생하는 예
var h1 = div1.clientHeight;  // 브라우저가 최신 레이아웃을 계산 → 리플로우 발생
var h2 = div2.clientHeight;  // 리플로우 없이 값만 가져옴 (레이아웃 변화 없음)

div1.style.height = h1 + 10 + "px";  // 스타일 변경 (아직 렌더링 X)
div2.style.height = h2 + 10 + "px";  // 스타일 변경 (아직 렌더링 X)

```

- 리플로우를 발생시키는 작업을 반복해서 해야한다면 변수에 저장(일급함수)해서 동작시킨다.
- 반복되는 리플로우 작업 전에 `display : none` 을 하고, 작업이 끝나면 다시 display를 활성화 시킨다.

### 오늘의 도전 과제와 해결 방법
- 도전 과제 1: 딥다이브 정리
- 도전 과제 2: JS 미니 퀘스트

### 오늘의 회고
- 자바스크립트는 나와 맞지 않다는 것을 오늘 확실하게 알게되었다. 변수가 선언되기 전에 변수를 사용하는데 실행이 된다는 점부터 이해할 수 없었다. 그러다 렉시컬 환경, 실행 컨텍스트라는 개념이 나오면서 나의 머릿속을 뒤집었다. 2,3주차에 cs개념을 처음 배우신 분들이 이런 느낌이지 않았을까 싶었다.
- 주말동안 오늘 딥다이브때 나눴던 얘기들에 대해 다시 곱씹어 봐야겠다.
