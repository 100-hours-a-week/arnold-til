## 날짜: 2025-02-24

# 실행 컨텍스트

- 함수가 호출될 때 생성되는 환경정보를 모아놓은 객체.
- 환경정보 : 코드가 실행되기 위해 필요한 정보 (변수, 함수, 스코프 등)
- 객체 : js 객체 형태로 구현. key:value 쌍의 데이터 컨테이너.
- 함수가 호출될 때 마다 생성됨. → 생명 주기를 갖고 있다.

## 변수 환경

- 실행 컨텍스트 안에 선언된 변수와 함수 정보를 담고 있는 환경
- 정적인 특성을 갖고 있어서 실행 도중 식별자 정보가 변경되지 않는다.

## 렉시컬 환경

- 실제 값에 대한 정보를 담고 있는 환경 맵
- 동적인 특성을 갖고 있어서 실행 도중 식별자 정보가 변경될 수 있다.
- 환경 레코드 : 호이스팅이 발생할 때 끌어올릴 변수를 저장하는 공간
- 외부 환경 참조 : 상위 스코프의 렉시컬 환경을 가르키는 참조 값

## 전역 실행 컨텍스트

- 전역 스코프의 모든 변수와 함수를 관리하는 실행 컨텍스트
- 최상위 컨텍스트로 1개만 생성된다.

## 함수 실행 컨텍스트

- 함수를 호출하면 그 함수의 변수와 함수를 관리하는 실행 컨텍스트
- 함수의 호출마다 생성되며 콜스택에 쌓였다가 함수 실행이 끝나면 제거됨

## 콜스택 과정

1. JS 코드 실행시 전역 실행 컨텍스트가 가장 먼저 쌓임.
2. 함수가 실행되면 그 위에 함수 실행 컨텍스트가 쌓임.
3. 함수가 종료되면 스택에서 pop해서 가장 최근에 실행된 함수 컨텍스트가 사라짐.
4. 모든 코드가 종료되면 전역 실행 컨텍스트가 사라짐.

## 스코프 체인

- 변수를 찾기 위해 현재 스코프에서부터 상위 스코프를 따라 올라가서 찾는 방식.
- 스코프체인으로 변수를 찾는데 실패하면 ReferenceError가 발생한다.

## 변수/함수 호이스팅

### 변수 호이스팅

- 변수의 선언만 끌어올려서 초기화랑은 상관이 없다.
- `var`는 `undefined`로 초기화, `let`, `const`는 초기화가 아예 안됨.

### 함수 호이스팅

- 힘수 선언문은 함수 전체를 끌어올림
- 함수 표현식은 그 변수 타입의 규칙에 따라 올라간다.

## ThisBinding

- this가 연결된 객체의 주소값

## var, let, const 차이

- 스코프가 다름. var는 함수 스코프, const, let는 블록 스코프
- const, let은 호이스팅 때 undefined로 초기화되지 않음. → 초기화와 선언을 분리

# 스코프

- 변수의 충돌을 막고, 메모리의 효율성을 높이며 가독성을 향상시킨다.

## 전역 스코프

- 어디서나 사용이 가능하도록 선언된 변수 범위

## 함수 스코프

- 함수 내부에서만 사용할 수 있는 범위
- 함수 호출과 함께 생성되고, 종료가 되면 소멸된다.
- 메모리 효율이 좋음

## 블록 스코프

- let, const로 선언된 코드 블록({}) 내부에서만 사용할 수 있는 변수 범위
- 코드 안정성을 높임
- var는 블록스코프의 특성을 갖지 않음

# this

- 함수가 호출될 때 실행되는 실행컨텍스트를 가리킨다.
- 전역this와 함수this는 스코프 오염의 문제 때문에 잘 사용하지 않는다.
- 화살표 함수 this는 상위 스코프에서 this값을 가져온다.

## 바인딩 결정 방식

- 기본 바인딩 : 함수를 단독으로 호출했을 때의 this로, 전역 스코프에서 바인딩됨
- 암시적 바인딩 : 객체의 메서드로 호출되었을 때의 this로, 해당 객체를 가리킴
- 명시적 바인딩 : call, apply, bind를 사용하여 this를 직접 원하는 객체에 바인딩할 수 있음
  - call과 apply는 첫번째 파라미터로 this로 사용할 객체를 전달한다, 두번째 파라미터로는 객체의 필드에 들어갈 값을 넣는데, 이 때 방식의 차이가 있다.

    ```jsx
    .call(user, user.name, user.interest);
    .apply(user, [user.name, user.interest]);
    ```

  - bind는 함수를 즉시 실행하지 않고 영구적으로 사용할 수 있는 함수를 반환한다.
- new 바인딩 : new 키워드를 이용하여 생성된 새로운 객체에 바인딩 됨.

## 일반함수와 화살표함수에서 this의 차이

- 일반 함수는 호출 방식에 따라 this가 바인딩 되는 값이 다르다.
- 화살표 함수는 this가 선언된 위치에서 결정된다.
- 화살표 함수는 call, apply, bind로 this를 바인딩 할 수 없다.

# 클로저

- 함수가 선언될 때 그 함수가 선언된 렉시컬 환경을 기억하여 외부 함수의 변수에도 접근이 가능하도록 하는 기능
- 외부함수의 변수를 기억하기 때문에 상태 유지가 가능하고, 데이터 은닉을 해서 보안에 좋다. 그러나 렉시컬 환경을 기억하다보니 메모리 사용량이 높아 리소스를 많이 소모한다.
  - 클로저가 더이상 필요하지 않다면 클로저 변수를 null로 초기화해서 메모리 공간을 비워준다.

## 클로저를 활용한 모듈패턴

- 클로저를 이용하여 데이터은닉과 캡슐화를 구현하는 패턴이다.
- 즉시 실행 함수를 사용하여 private 변수와 public 메소드를 정의한다.

# 프로토타입

- 객체가 상속받는 속성, 메서드의 집합. js에서 class의 조상님 느낌
- 함수가 생성되면서 자동으로 생성이 된다.

## 프로토타입 체인

- 속성을 찾을 때 그 속성을 찾을 때 까지 부모를 올라가서 찾는다. → 끝까지 없으면 undefined 반환

## class와 프로토타입의 차이

- class는 프로토타입을 편하게 사용하도록 만들었지만 내부적으로는 프로토타입 기반으로 동작한다.

### 오늘의 도전 과제와 해결 방법
- 도전 과제 1: TIL 정리
- 도전 과제 2: 커뮤니티 과제 fetch 적용하기
