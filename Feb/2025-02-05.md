## 날짜: 2025-02-05

### 스크럼
- 학습 목표 1 : CLI 동기 프로그램 간단한 스레드 구현
- 학습 목표 2 : 알고리즘 풀기

### 새로 배운 내용
## 블로킹

- 현재 작업이 끝나야 다음 작업이 시작될 수 있는 것.
- 프로그램의 실행 흐름을 알기 쉬움.
- 작업의 제어권을 넘기는 방식.

## 논블로킹

- 현재 작업이 끝나길 기다리지 않고 바로 다음 작업을 진행할 수 있는 것.
- 여러 작업을 동시에 하기 때문에 자원을 효율적으로 사용 가능.
- 작업의 제어권을 넘겨주고 실행이 시작되면 다시 돌려받는 방식.

## 동기

- 순서를 정하고, 그 순서대로 작업이 진행되는 방식.
- 작업의 제어권을 넘겨주고 실행이 되면 다시 돌려받지만, 작업이 완료될 때 까지 기다림.

## 비동기

- 작업의 순서를 고려하지 않고, 각자의 작업을 독립적으로 실행한다.
- 알림 등의 형태로 작업의 완료 여부를 받음.
- 작업의 제어권을 넘겨주고 실행이 되면 다시 돌려받고, 작업의 결과에 대해 신경쓰지 않음.

### 동기/비동기의 차이

- 작업의 순서(흐름)를 고려하는가 하지 않는가의 차이이다.
- 파일 A, B가 있을 때, 동기는 파일 A를 다 읽고 그 다음 B를 읽을 수 있다. 비동기는 파일 A를 읽으면서 파일 B를 읽을 수 있다.

### 블로킹과 논블록킹 차이

- 작업의 흐름 자체를 막느냐 막지 않느냐의 차이이다.
- 작업 A, B에 대해 작업 A가 실행 중 작업 B를 실행한다는 상황이다. 블로킹은 작업 A가 작업 B에게 제어권을 넘겨주고, 작업 B가 끝나면 작업 A에게 제어권을 돌려준다. 논블록킹은 작업 A가 작업 B에게 제어권을 넘겨주고 작업 B가 실행되면 제어권을 돌려준다. 그렇기 때문에 작업 B가 실행되면서도 작업 A가 실행될 수 있다.

### 동기+블로킹 vs 동기 + 논블록킹

- 동기 + 블로킹
    - 작업 A의 실행이 완료되면 작업 B가 실행되며 제어권을 작업 B에게 넘겨주고, 작업 B가 끝날 때 까지 기다린다. 작업 B가 끝나면 제어권을 작업 A에게 넘겨주고 작업 A가 실행된다.
    - 다른 작업의 결과에 영향을 받는다.
- 동기 + 논블록킹
    - 작업 A가 실행되면서 작업 B가 실행된다. 작업 A는 작업 B가 끝날때까지 자기의 일을 하면서 작업 B에게 일이 끝났는지를 계속 확인한다.
    - 결과에 대한 응답을 지속적으로 요청한다.
    - 예시로는 프로그램 다운로드 할 때, 로딩바가 계속 차는것. 로딩바(A)는 다운로드(B)가 어느정도 일을 했는지 지속적으로 응답을 받으면서 자신의 로딩바를 점점 채워나가는 일을 한다.

### 비동기 I/O와 논블로킹 I/O

- 비동기는 다른 작업의 진행이 완료되면 콜백을 받고, 하던 일을 마저 한다. OS단에서 직접 완료 상태를 알려준다.
- 논블로킹은 다른 작업의 진행이 필요할 때 완료되지 않았다면 에러를 반환하고, 프로그램은 블로킹 하지 않는다. 지속적으로 풀링하며 다른 작업의 진행 상태를 확인한다.

### 웹 서버 아키텍처에서 논블로킹 방식이 주는 성능적 이점

- 서버는 더 많은 요청을 동시에 처리할 수 있고, 이를 통해 I/O 대기시간을 줄여 응답을 더 빨리 할 수 있다. 또한 스레드의 수를 줄여서 자원이 낭비되는 문제를 방지할 수 있다.

### 코딩테스트 관련 팁

- 제출, 테스트 기록 남음.
- 다양한 테스트 케이스 등록해라.
- 주석 등으로 자신의 생각 흐름을 기록하라.
- 변수명도 신경쓰기.

### 오늘의 도전 과제와 해결 방법
- 도전 과제 1: CLI 동기 프로그램 간단한 스레드 구현
- 도전 과제 2: 알고리즘 풀기

### 오늘의 회고
- Sync, Async는 알고 있었지만, Block, Non-Block이라는 새로운 개념에 대해 알게 되었다. 사실 어제 스레드 공부하고 찾아보다 Block에 관한 내용은 접하긴 했는데 그저 Sync와 비슷한 개념으로 생각하고 넘겼다.
- Non-Block과 Async는 여러 프로그램을 동시에 실행시킨다는 공통점이 있지만, 다른 프로그램의 결과에 대한 처리 방식이 다르다. 헷갈릴 수 있는 부분이지만 잘 기억해 놓도록 하자.
