## 날짜: 2025-02-13

# HTTP 자격증명 헤더

- 클라이언트-서버 인증 과정에서 사용자의 자격을 확인하기 위해 사용되는 헤더
- 보안은 클라이언트, 서버 모두 필수 요소
- 클라이언트에서 서버로 인증 정보를 넘김
- 서버는 필요한 정보를 꺼내 검증을 하고 상태코드를 클라이언트로 넘김
- WWW-Authenticate : 서버가 클라이언트에게 인증이 필요하다고 알리는 헤더. 어떤 인증 방식이 필요한지를 같이 알려줌
- Authorization : 인증에 필요한 정보를 제공하는 헤더

## Basic Authentication

- 가장 기본이 되는 인증 방식으로, 구현은 간단하지만 보안에 취약
- 이름과 비밀번호를 콜론으로 구분해서 인코딩

## Digest Authentication

- Basic에서 보안이 강화된 인증 방식
- 비밀번호에 해시함수를 적용하여 인코딩

## Bearer Token

- JWT, OAuth 2.0 등 토큰 기반 인증 시스템에 사용되는 토큰
- 서버는 토큰의 유효성을 검사한다.
- 토큰에는 사용자의 정보가 포함되어있다.
- 토큰이 탈취되면 보안에 취약하다는 단점이 있다. → 만료시간을 잘 설정해야 함. or 리프레시 토큰과 함께 사용.
- access token을 포함하는 HTTP 요청 방식. 엄밀히 말하면 access token과는 다르지만 혼용해서 사용함.

### Access Token과 Refresh Token

- access token은 클라이언트에서 사용자의 정보가 포함된 리소스를 요청할 때 마다 필요한 토큰이다.
- refresh token은 만료 시간이 길고 서버의 db에 저장된다. access token을 재발급 하는 역할을 하는 토큰이다.
- access token의 만료 시간에 대한 탈취 문제 이슈로 refresh token을 함께 사용한다.
- refresh token은 어떻게 안전할 수 있는가? → 애초에 저장을 secure storage라는 보안이 강화된 저장소에 저장하고, 서버에서 관리하기 때문에 더 안전하다.
- access token을 안전하게 저장하면 되는 것 아닌가? → access token은 언제든지 클라이언트가 꺼내서 사용해야 하기 때문에 훨씬 탈취에 취약하다.

# JWT

- json 형식을 포함하여 웹 환경에서 모든 정보를 담고있는 토큰
- 확장성, 유연성
- stateless : 서버 확장성 극대화. 사용자 인증 정보, 데이터를 토큰이 포함하기 때문에 세션 상태를 저장할 필요 없음
- JWT vs Session : 사용자별 세션 데이터를 저장해야 해서 사용자가 늘어나면 리소스가 많이 듦. 그러나 JWT는 클라에 저장되어서 서버에 부담이 적다.
- 액세스 토큰이 탈취된다면 보안에 문제가 생기기 때문에 리프레시 토큰과 함께 사용한다.
- 토큰 발급 과정
  - 사용자 인증 : 클라이언트에서 받은 사용자의 정보를 검증
  - Payload 생성 : 토큰에 담을 정보를 포함하는 JSON 형식의 데이터를 생성
  - Header 생성 : 토큰 유형, 서명알고리즘 등이 포함된 JSON 형식의 데이터를 생성
  - 서명 생성 : 서버의 비밀키로 생성
  - JWT 발급
- 토큰 전송 방법
  - Auth Header : 서버에서 쉽게 추출하고 검증할 수 있지만 CORS 이슈가 있다.
  - 쿠키 : CORS문제가 발생하지 않지만, CSRF 공격에 취약하다.
- 토큰 검증
  - JWT 추출 : auth header에서 추출
  - JWT 파싱 : Header, Payload, signature를 분리하여 각 정보를 확인
  - 서명 검증 : JWT가 위조되지 않았는지 확인
  - 클레임 검증 : payload에 포함된 사용자의 신원, 권한, 토큰 유효기간 등을 확인
- 권한에 따른 처리

### JWT 구성 요소

- Header : 토큰의 유형과 서명 알고리즘을 명시
- Payload : 사용자에 관한 정보, 토큰에 관한 정보를 담고 있음
- Signature : 토큰이 변조되었는지를 확인하기위해 헤더와 페이로드를 하나로 모아서 서버의 비밀키로 암호화한 것

### JWT 서명 및 암호화 알고리즘

- RSA : Rivest,Shamir, Adleman의 이름을 따서 만든 공개키 알고리즘. 소인수 분해를 이용하여 암호화한다.
- HMAC : 메시지의 위조 여부를 확인하는 알고리즘(MAC)에 해시함수를 사용한 것
- ECDSA : 타원 곡선을 이용한 암호화 방식

# OAuth 2.0

- 사용자의 비밀번호 노출 없이 인증 권한을 안전하게 부여하는 프로토콜
- 인증 요청 : 클라이언트 → 인증을 관리하는 서버에게 요청
- 인증 및 코드 발급 : 인증을 관리하는 서버에서는 사용자를 확인하고 인증 코드를 발급하여 클라이언트로 보냄
- 토큰 교환 : 클라이언트는 인증 코드를 access token으로 변환
- 리소스 접근 : access token을 이용하여 사용자의 데이터 접근 가능
- 2.0 vs 1.0 : 1.0은 서명 검증 과정이 복잡한 반면 2.0은 access token을 헤더에 포함하기만 하면 돼서 간단하다.

# 보안 대책 강화

## CSRF (Cross Site Request Forgery)

- 웹사이트가 신뢰하는 유저로부터 권한이 없는 커맨드(수정, 삭제, 등록 등)를 받는 공격.
- 비밀번호를 바꿀 때 현재 비밀번호가 필요없다고 가정해보자. 공격자는 비밀번호를 바꾸는 코드가 뭔지 안다면, 현재 비밀번호 없이도 유저의 비밀번호를 바꿀 수 있다.
- 해결법
  - 쿠키 유효시간을 설정한다.
  - get, post 할 때 인증을 요구한다.
  - post할때는 get 파라미터를 버리게한다.

## XSS (Cross Site Scripting)

- 코드 주입 공격 유형으로 공격자가 웹에 스크립트 코드를 삽입해서 원치 않는 기능을 동작시키는 공격
- 해결법
  - 애초에 사용자가 스크립트를 입력 못하게 제한을 준다.
  - 특정 문자에 대해서는 다른 문자로 대체하도록 한다.

### 오늘의 도전 과제와 해결 방법
- 도전 과제 1 : 오늘 배운 내용 정리
- 도전 과제 2 : 2주차 과제 피드백 정리
- 도전 과제 3 : 3주차 과제 리틀리 만들기

### 오늘의 회고
- 백엔드 개발을 하면서 JWT나 OAuth를 사용해 본적은 있지만 이렇게 이론적으로 깊이 공부해 본적은 없었다. 이번 기회에 제대로 배워서 다음에 쓸 때는 확실히 이해하고 사용할 수 있을 것 같다.